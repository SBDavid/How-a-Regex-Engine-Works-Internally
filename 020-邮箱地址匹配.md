邮箱匹配是非常常用的，历史上邮箱名称的规则发生过很多次变化，所以没有哪一个正则表达式可以100%的匹配所有的邮箱。根据不同的邮箱名称规则我们可以对表达式作出调整，这样我们可以得到一个能匹配绝大多数邮箱的表达式。

例如我们可以使用`\b[A-Z0-9._%+-]+@[A-Z0-9.-]+\.[A-Z]{2,}\b`在文本中搜索邮箱地址。注意使用这个表达式的时候需要**关闭大小写敏感**的模式。这个表达式使用了[词语边界](https://blog.csdn.net/billll/article/details/84900465)，如果把词语边界替换成[位置字符](https://blog.csdn.net/billll/article/details/84891487)：`^[A-Z0-9._%+-]+@[A-Z0-9.-]+\.[A-Z]{2,}$`，我们就可以用它验证用户的输入是否是合法的邮箱。

## 控制邮箱的总长
我们可以使用[正向预测断言](https://blog.csdn.net/billll/article/details/86411282)来锁定邮箱的总长度，例如`^(?=[A-Z0-9@._%+-]{6,254}$)[A-Z0-9._%+-]{1,64}@(?:[A-Z0-9-]{1,63}\.){1,8}[A-Z]{2,63}$`可以匹配长度在6到254之间的邮箱。

## 使用激活链接验证邮箱的准确性
正则表达式并不能100%确定一个邮箱是否合法，所以我们没有必要使用过度复杂的表示式去验证邮箱。复杂的表达式不易于理解，甚至可能存在性能问题，在实际工作中不推荐使用过于复杂的表达式去匹配邮箱。此外即使邮箱的名称合法，也不能证明邮箱实际存在。我们可以发送带有激活链接的邮箱来确认邮箱的可用性。

---

> 如果文章出现错误，请给我提Issues - -
[Github地址](https://github.com/SBDavid/How-a-Regex-Engine-Works-Internally)

需要进一步翻译的内容: 

[原文](https://www.regular-expressions.info/email.html)